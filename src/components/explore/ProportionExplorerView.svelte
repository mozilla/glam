<script>
  import { createEventDispatcher } from 'svelte';
  import { tweened } from 'svelte/motion';
  import { cubicOut as easing } from 'svelte/easing';

  import ProbeExplorer from './ProbeExplorer.svelte';
  import KeySelectionControl from '../controls/KeySelectionControl.svelte';
  import TimeHorizonControl from '../controls/TimeHorizonControl.svelte';
  import ProportionMetricTypeControl from '../controls/ProportionMetricTypeControl.svelte';
  import ProbeKeySelector from '../controls/ProbeKeySelector.svelte';

  import {
    formatPercent,
    formatCount,
    formatPercentDecimal,
  } from '../../utils/formatters';

  import {
    overTimeTitle,
    proportionsOverTimeDescription,
  } from '../../utils/constants';

  import {
    gatherProbeKeys,
    gatherAggregationTypes,
  } from '../../utils/probe-utils';

  export let aggregationLevel = 'build_id';
  export let data;
  export let probeType;
  export let activeBuckets;
  export let bucketColorMap;
  export let bucketOptions;
  export let timeHorizon = 'MONTH';
  export let metricType = 'proportions';

  export let bucketSortOrder = (a, b) => (a < b ? 1 : -1);

  const dispatch = createEventDispatcher();

  function makeSelection(type) {
    return function onSelection(event) {
      dispatch('selection', { selection: event.detail.selection, type });
    };
  }

  let aggregationTypes = gatherAggregationTypes(data);
  let probeKeys = gatherProbeKeys(data);
  let currentKey = probeKeys[0];
  let currentAggregation = aggregationTypes[0];

  // set the audience size when the reference updates.
  let reference;
  const movingAudienceSize = tweened(0, { duration: 500, easing });
  $: if (reference) movingAudienceSize.set(reference.audienceSize);

  $: if (currentKey && reference) {
    const ref = data[currentKey][currentAggregation].find(
      (d) => d.label.toString() === reference.label.toString()
    );
    reference = ref;
  }

  function filterResponseData(d, agg, key) {
    return d.filter(
      (di) => di.client_agg_type === agg && di.metric_key === key
    );
  }

  $: selectedData = filterResponseData(data, currentAggregation, currentKey);
</script>

<style>
  h2 {
    margin: 0;
  }

  .body-content {
    margin-top: var(--space-2x);
  }

  .data-graphics {
    margin-top: var(--space-4x);
  }

  .small-multiple {
    margin-bottom: var(--space-8x);
  }
</style>

<div class="body-content">

  <slot />

  <div class="body-control-row body-control-row--stretch">
    <div class="body-control-set">
      {#if aggregationLevel === 'build_id'}
        <label class="body-control-set--label">Time Horizon</label>
        <TimeHorizonControl
          horizon={timeHorizon}
          on:selection={makeSelection('timeHorizon')} />
      {/if}
    </div>

    <div class="body-control-set">
      <label class="body-control-set--label">Categories</label>
      <KeySelectionControl
        sortFunction={bucketSortOrder}
        options={bucketOptions}
        selections={activeBuckets}
        on:selection={makeSelection('activeBuckets')}
        colorMap={bucketColorMap} />
    </div>
  </div>

  <div class="body-control-row body-control-row--stretch">
    <div class="body-control-set">
      <label class="body-control-set--label">Metric Type</label>
      <ProportionMetricTypeControl
        {metricType}
        on:selection={makeSelection('metricType')} />
    </div>
    {#if probeKeys && probeKeys.length > 1}
      <div class="body-control-set">
        <label class="body-control-set--label">Key</label>
        <ProbeKeySelector options={probeKeys} bind:currentKey />
      </div>
    {/if}
  </div>

  <div class="data-graphics">
    {#each probeKeys as key, i (key)}
      {#each aggregationTypes as aggType, i (aggType + timeHorizon + probeType + metricType)}
        {#if key === currentKey && (aggregationTypes.length === 1 || aggType === currentAggregation)}
          <div class="small-multiple">
            <ProbeExplorer
              bind:reference
              title={key === 'undefined' ? '' : key}
              aggregationsOverTimeTitle={overTimeTitle(metricType, aggregationLevel)}
              aggregationsOverTimeDescription={proportionsOverTimeDescription(metricType, aggregationLevel)}
              summaryLabel="cat."
              data={selectedData}
              {probeType}
              activeBins={activeBuckets}
              {timeHorizon}
              binColorMap={bucketColorMap}
              {metricType}
              showViolins={false}
              {aggregationLevel}
              pointMetricType={metricType}
              yTickFormatter={metricType === 'proportions' ? formatPercent : formatCount}
              summaryNumberFormatter={metricType === 'proportions' ? formatPercentDecimal : formatCount}
              yScaleType={'linear'}
              yDomain={[0, Math.max(...selectedData
                    .map((d) => Object.values(d[metricType]))
                    .flat())]} />
          </div>
        {/if}
      {/each}
    {/each}
  </div>
</div>
